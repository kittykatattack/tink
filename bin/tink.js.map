{"version":3,"sources":["../src/tink.js"],"names":[],"mappings":"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","file":"tink.js","sourcesContent":["class Tink {\n  constructor(PIXI, element, scale = 1) {\n\n    //Add element and scale properties\n    this.element = element;\n    this._scale = scale;\n\n    //An array to store all the draggable sprites\n    this.draggableSprites = [];\n\n    //An array to store all the pointer objects\n    //(there will usually just be one)\n    this.pointers = [];\n\n    //An array to store all the buttons and button-like\n    //interactive sprites\n    this.buttons = [];\n\n    //A local PIXI reference\n    this.PIXI = PIXI;\n\n    //Aliases for Pixi objects\n    this.TextureCache = this.PIXI.utils.TextureCache;\n\n    //Note: change MovieClip to AnimatedSprite for Pixi v4\n    this.AnimatedSprite = this.PIXI.extras.MovieClip;\n    this.Texture = this.PIXI.Texture;\n  }\n\n  get scale() {\n    return this._scale;\n  }\n\n  set scale(value) {\n    this._scale = value;\n\n    //Update scale values for all pointers\n    this.pointers.forEach(pointer => pointer.scale = value);\n  }\n\n  //`makeDraggable` lets you make a drag-and-drop sprite by pushing it\n  //into the `draggableSprites` array\n  makeDraggable(...sprites) {\n\n    //If the first argument isn't an array of sprites...\n    if (!(sprites[0] instanceof Array)) {\n      sprites.forEach(sprite => {\n        this.draggableSprites.push(sprite);\n\n        //If the sprite's `draggable` property hasn't already been defined by\n        //another library, like Hexi, define it\n        if (sprite.draggable === undefined) {\n          sprite.draggable = true;\n          sprite._localDraggableAllocation = true;\n        }\n      });\n    }\n\n    //If the first argument is an array of sprites...\n    else {\n      let spritesArray = sprites[0];\n      if (spritesArray.length > 0) {\n        for (let i = spritesArray.length - 1; i >= 0; i--) {\n          let sprite = spritesArray[i];\n          this.draggableSprites.push(sprite);\n\n          //If the sprite's `draggable` property hasn't already been defined by\n          //another library, like Hexi, define it\n          if (sprite.draggable === undefined) {\n            sprite.draggable = true;\n            sprite._localDraggableAllocation = true;\n          }\n        }\n      }\n    }\n  }\n\n  //`makeUndraggable` removes the sprite from the `draggableSprites`\n  //array\n  makeUndraggable(...sprites) {\n\n    //If the first argument isn't an array of sprites...\n    if (!(sprites[0] instanceof Array)) {\n      sprites.forEach(sprite => {\n        this.draggableSprites.splice(this.draggableSprites.indexOf(sprite), 1);\n        if (sprite._localDraggableAllocation === true) sprite.draggable = false;\n      });\n    }\n\n    //If the first argument is an array of sprites\n    else {\n      let spritesArray = sprites[0];\n      if (spritesArray.length > 0) {\n        for (let i = spritesArray.length - 1; i >= 0; i--) {\n          let sprite = spritesArray[i];\n          this.draggableSprites.splice(this.draggableSprites.indexOf(sprite), 1);\n          if (sprite._localDraggableAllocation === true) sprite.draggable = false;\n        }\n      }\n    }\n  }\n\n  makePointer(element = this.element, scale = this.scale) {\n\n    //Get a reference to Tink's global `draggableSprites` array\n    let draggableSprites = this.draggableSprites;\n\n    //Get a reference to Tink's `addGlobalPositionProperties` method\n    let addGlobalPositionProperties = this.addGlobalPositionProperties;\n\n    //The pointer object will be returned by this function\n    let pointer = {\n      element: element,\n      _scale: scale,\n\n      //Private x and y properties\n      _x: 0,\n      _y: 0,\n\n      //Width and height\n      width: 1,\n      height: 1,\n\n      //The public x and y properties are divided by the scale. If the\n      //HTML element that the pointer is sensitive to (like the canvas)\n      //is scaled up or down, you can change the `scale` value to\n      //correct the pointer's position values\n      get x() {\n        return this._x / this.scale;\n      },\n      get y() {\n        return this._y / this.scale;\n      },\n\n      //Add `centerX` and `centerY` getters so that we\n      //can use the pointer's coordinates with easing\n      //and collision functions\n      get centerX() {\n        return this.x;\n      },\n      get centerY() {\n        return this.y;\n      },\n\n      //`position` returns an object with x and y properties that\n      //contain the pointer's position\n      get position() {\n        return {\n          x: this.x,\n          y: this.y\n        };\n      },\n\n      get scale() {\n        return this._scale;\n      },\n      set scale(value) {\n        this._scale = value;\n      },\n\n      //Add a `cursor` getter/setter to change the pointer's cursor\n      //style. Values can be \"pointer\" (for a hand icon) or \"auto\" for \n      //an ordinary arrow icon.\n      get cursor() {\n        return this.element.style.cursor;\n      },\n      set cursor(value) {\n        this.element.style.cursor = value;\n      },\n\n      //Booleans to track the pointer state\n      isDown: false,\n      isUp: true,\n      tapped: false,\n\n      //Properties to help measure the time between up and down states\n      downTime: 0,\n      elapsedTime: 0,\n\n      //Optional `press`,`release` and `tap` methods\n      press: undefined,\n      release: undefined,\n      tap: undefined,\n\n      //A `dragSprite` property to help with drag and drop\n      dragSprite: null,\n\n      //The drag offsets to help drag sprites\n      dragOffsetX: 0,\n      dragOffsetY: 0,\n\n      //A property to check whether or not the pointer\n      //is visible\n      _visible: true,\n      get visible() {\n        return this._visible;\n      },\n      set visible(value) {\n        if (value === true) {\n          this.cursor = \"auto\";\n        } else {\n          this.cursor = \"none\";\n        }\n        this._visible = value;\n      },\n\n      //The pointer's mouse `moveHandler`\n      moveHandler(event) {\n\n        //Get the element that's firing the event\n        let element = event.target;\n\n        //Find the pointerâ€™s x and y position (for mouse).\n        //Subtract the element's top and left offset from the browser window\n        this._x = (event.pageX - element.offsetLeft);\n        this._y = (event.pageY - element.offsetTop);\n\n        //Prevent the event's default behavior \n        event.preventDefault();\n      },\n\n      //The pointer's `touchmoveHandler`\n      touchmoveHandler(event) {\n        let element = event.target;\n\n        //Find the touch point's x and y position\n        this._x = (event.targetTouches[0].pageX - element.offsetLeft);\n        this._y = (event.targetTouches[0].pageY - element.offsetTop);\n        event.preventDefault();\n      },\n\n      //The pointer's `downHandler`\n      downHandler(event) {\n\n        //Set the down states\n        this.isDown = true;\n        this.isUp = false;\n        this.tapped = false;\n\n        //Capture the current time\n        this.downTime = Date.now();\n\n        //Call the `press` method if it's been assigned\n        if (this.press) this.press();\n        event.preventDefault();\n      },\n\n      //The pointer's `touchstartHandler`\n      touchstartHandler(event) {\n        let element = event.target;\n\n        //Find the touch point's x and y position\n        this._x = event.targetTouches[0].pageX - element.offsetLeft;\n        this._y = event.targetTouches[0].pageY - element.offsetTop;\n\n        //Set the down states\n        this.isDown = true;\n        this.isUp = false;\n        this.tapped = false;\n\n        //Capture the current time\n        this.downTime = Date.now();\n\n        //Call the `press` method if it's been assigned\n        if (this.press) this.press();\n        event.preventDefault();\n      },\n\n      //The pointer's `upHandler`\n      upHandler(event) {\n\n        //Figure out how much time the pointer has been down\n        this.elapsedTime = Math.abs(this.downTime - Date.now());\n\n        //If it's less than 200 milliseconds, it must be a tap or click\n        if (this.elapsedTime <= 200 && this.tapped === false) {\n          this.tapped = true;\n\n          //Call the `tap` method if it's been assigned\n          if (this.tap) this.tap();\n        }\n        this.isUp = true;\n        this.isDown = false;\n\n        //Call the `release` method if it's been assigned\n        if (this.release) this.release();\n        event.preventDefault();\n      },\n\n      //The pointer's `touchendHandler`\n      touchendHandler(event) {\n\n        //Figure out how much time the pointer has been down\n        this.elapsedTime = Math.abs(this.downTime - Date.now());\n\n        //If it's less than 200 milliseconds, it must be a tap or click\n        if (this.elapsedTime <= 200 && this.tapped === false) {\n          this.tapped = true;\n\n          //Call the `tap` method if it's been assigned\n          if (this.tap) this.tap();\n        }\n        this.isUp = true;\n        this.isDown = false;\n\n        //Call the `release` method if it's been assigned\n        if (this.release) this.release();\n        event.preventDefault();\n      },\n\n      //`hitTestSprite` figures out if the pointer is touching a sprite\n      hitTestSprite(sprite) {\n\n        //Add global `gx` and `gy` properties to the sprite if they\n        //don't already exist\n        addGlobalPositionProperties(sprite);\n\n        //The `hit` variable will become `true` if the pointer is\n        //touching the sprite and remain `false` if it isn't\n        let hit = false;\n\n        //Find out the sprite's offset from its anchor point\n        let xAnchorOffset, yAnchorOffset;\n        if (sprite.anchor !== undefined) {\n          xAnchorOffset = sprite.width * sprite.anchor.x;\n          yAnchorOffset = sprite.height * sprite.anchor.y;\n        } else {\n          xAnchorOffset = 0;\n          yAnchorOffset = 0;\n        }\n\n        //Is the sprite rectangular?\n        if (!sprite.circular) {\n\n          //Get the position of the sprite's edges using global\n          //coordinates\n          let left = sprite.gx - xAnchorOffset,\n            right = sprite.gx + sprite.width - xAnchorOffset,\n            top = sprite.gy - yAnchorOffset,\n            bottom = sprite.gy + sprite.height - yAnchorOffset;\n\n          //Find out if the pointer is intersecting the rectangle.\n          //`hit` will become `true` if the pointer is inside the\n          //sprite's area\n          hit = this.x > left && this.x < right && this.y > top && this.y < bottom;\n        }\n\n        //Is the sprite circular?\n        else {\n          //Find the distance between the pointer and the\n          //center of the circle\n          let vx = this.x - (sprite.gx + (sprite.width / 2) - xAnchorOffset),\n            vy = this.y - (sprite.gy + (sprite.width / 2) - yAnchorOffset),\n            distance = Math.sqrt(vx * vx + vy * vy);\n\n          //The pointer is intersecting the circle if the\n          //distance is less than the circle's radius\n          hit = distance < sprite.width / 2;\n        }\n        //Check the value of `hit`\n        return hit;\n      }\n    };\n\n    //Bind the events to the handlers\n    //Mouse events\n    element.addEventListener(\n      \"mousemove\", pointer.moveHandler.bind(pointer), false\n    );\n    element.addEventListener(\n      \"mousedown\", pointer.downHandler.bind(pointer), false\n    );\n\n    //Add the `mouseup` event to the `window` to\n    //catch a mouse button release outside of the canvas area\n    window.addEventListener(\n      \"mouseup\", pointer.upHandler.bind(pointer), false\n    );\n\n    //Touch events\n    element.addEventListener(\n      \"touchmove\", pointer.touchmoveHandler.bind(pointer), false\n    );\n    element.addEventListener(\n      \"touchstart\", pointer.touchstartHandler.bind(pointer), false\n    );\n\n    //Add the `touchend` event to the `window` object to\n    //catch a mouse button release outside of the canvas area\n    window.addEventListener(\n      \"touchend\", pointer.touchendHandler.bind(pointer), false\n    );\n\n    //Disable the default pan and zoom actions on the `canvas`\n    element.style.touchAction = \"none\";\n\n    //Add the pointer to Tink's global `pointers` array\n    this.pointers.push(pointer);\n\n    //Return the pointer\n    return pointer;\n  }\n\n  //Many of Tink's objects, like pointers, use collision\n  //detection using the sprites' global x and y positions. To make\n  //this easier, new `gx` and `gy` properties are added to sprites\n  //that reference Pixi sprites' `getGlobalPosition()` values.\n  addGlobalPositionProperties(sprite) {\n    if (sprite.gx === undefined) {\n      Object.defineProperty(\n        sprite,\n        \"gx\", {\n          get() {\n            return sprite.getGlobalPosition().x;\n          }\n        }\n      );\n    }\n\n    if (sprite.gy === undefined) {\n      Object.defineProperty(\n        sprite,\n        \"gy\", {\n          get() {\n            return sprite.getGlobalPosition().y;\n          }\n        }\n      );\n    }\n  }\n\n  //A method that implments drag-and-drop functionality \n  //for each pointer\n  updateDragAndDrop(draggableSprites) {\n\n    //Create a pointer if one doesn't already exist\n    if (this.pointers.length === 0) {\n      this.makePointer(this.element, this.scale);\n    }\n\n    //Loop through all the pointers in Tink's global `pointers` array\n    //(there will usually just be one, but you never know)\n    this.pointers.forEach(pointer => {\n\n      //Check whether the pointer is pressed down\n      if (pointer.isDown) {\n\n        //You need to capture the co-ordinates at which the pointer was\n        //pressed down and find out if it's touching a sprite\n\n        //Only run pointer.code if the pointer isn't already dragging\n        //sprite\n        if (pointer.dragSprite === null) {\n\n          //Loop through the `draggableSprites` in reverse to start searching at the bottom of the stack\n          for (let i = draggableSprites.length - 1; i > -1; i--) {\n\n            //Get a reference to the current sprite\n            let sprite = draggableSprites[i];\n\n            //Check for a collision with the pointer using `hitTestSprite`\n            if (pointer.hitTestSprite(sprite) && sprite.draggable) {\n\n              //Calculate the difference between the pointer's\n              //position and the sprite's position\n              pointer.dragOffsetX = pointer.x - sprite.gx;\n              pointer.dragOffsetY = pointer.y - sprite.gy;\n\n              //Set the sprite as the pointer's `dragSprite` property\n              pointer.dragSprite = sprite;\n\n              //The next two lines re-order the `sprites` array so that the\n              //selected sprite is displayed above all the others.\n              //First, splice the sprite out of its current position in\n              //its parent's `children` array\n              let children = sprite.parent.children;\n              children.splice(children.indexOf(sprite), 1);\n\n              //Next, push the `dragSprite` to the end of its `children` array so that it's\n              //displayed last, above all the other sprites\n              children.push(sprite);\n\n              //Reorganize the `draggableSpites` array in the same way\n              draggableSprites.splice(draggableSprites.indexOf(sprite), 1);\n              draggableSprites.push(sprite);\n\n              //Break the loop, because we only need to drag the topmost sprite\n              break;\n            }\n          }\n        }\n\n        //If the pointer is down and it has a `dragSprite`, make the sprite follow the pointer's\n        //position, with the calculated offset\n        else {\n          pointer.dragSprite.x = pointer.x - pointer.dragOffsetX;\n          pointer.dragSprite.y = pointer.y - pointer.dragOffsetY;\n        }\n      }\n\n      //If the pointer is up, drop the `dragSprite` by setting it to `null`\n      if (pointer.isUp) {\n        pointer.dragSprite = null;\n      }\n\n      //Change the mouse arrow pointer to a hand if it's over a\n      //draggable sprite\n      draggableSprites.some(sprite => {\n        if (pointer.hitTestSprite(sprite) && sprite.draggable) {\n          if (pointer.visible) pointer.cursor = \"pointer\";\n          return true;\n        } else {\n          if (pointer.visible) pointer.cursor = \"auto\";\n          return false;\n        }\n      });\n    });\n  }\n\n  makeInteractive(o) {\n\n    //The `press`,`release`, `over`, `out` and `tap` methods. They're `undefined`\n    //for now, but they can be defined in the game program\n    o.press = o.press || undefined;\n    o.release = o.release || undefined;\n    o.over = o.over || undefined;\n    o.out = o.out || undefined;\n    o.tap = o.tap || undefined;\n\n    //The `state` property tells you the button's\n    //current state. Set its initial state to \"up\"\n    o.state = \"up\";\n\n    //The `action` property tells you whether its being pressed or\n    //released\n    o.action = \"\";\n\n    //The `pressed` and `hoverOver` Booleans are mainly for internal\n    //use in this code to help figure out the correct state.\n    //`pressed` is a Boolean that helps track whether or not\n    //the sprite has been pressed down\n    o.pressed = false;\n\n    //`hoverOver` is a Boolean which checks whether the pointer\n    //has hovered over the sprite\n    o.hoverOver = false;\n\n    //tinkType is a string that will be set to \"button\" if the \n    //user creates an object using the `button` function\n    o.tinkType = \"\";\n\n    //Set `enabled` to true to allow for interactivity\n    //Set `enabled` to false to disable interactivity\n    o.enabled = true;\n\n    //Add the sprite to the global `buttons` array so that it can\n    //be updated each frame in the `updateButtons method\n    this.buttons.push(o);\n  }\n\n  //The `updateButtons` method will be called each frame \n  //inside the game loop. It updates all the button-like sprites\n  updateButtons() {\n\n    //Create a pointer if one doesn't already exist\n    if (this.pointers.length === 0) {\n      this.makePointer(this.element, this.scale);\n    }\n\n    //Loop through all of Tink's pointers (there will usually\n    //just be one)\n    this.pointers.forEach(pointer => {\n      pointer.shouldBeHand = false;\n      //Loop through all the button-like sprites that were created\n      //using the `makeInteractive` method\n      this.buttons.forEach(o => {\n\n        //Only do this if the interactive object is enabled\n        if (o.enabled) {\n\n          //Figure out if the pointer is touching the sprite\n          let hit = pointer.hitTestSprite(o);\n\n          //1. Figure out the current state\n          if (pointer.isUp) {\n\n            //Up state\n            o.state = \"up\";\n\n            //Show the first image state frame, if this is a `Button` sprite\n            if (o.tinkType === \"button\") o.gotoAndStop(0);\n          }\n\n          //If the pointer is touching the sprite, figure out\n          //if the over or down state should be displayed\n          if (hit) {\n\n            //Over state\n            o.state = \"over\";\n\n            //Show the second image state frame if this sprite has\n            //3 frames and it's a `Button` sprite\n            if (o.totalFrames && o.totalFrames === 3 && o.tinkType === \"button\") {\n              o.gotoAndStop(1);\n            }\n\n            //Down state\n            if (pointer.isDown) {\n              o.state = \"down\";\n\n              //Show the third frame if this sprite is a `Button` sprite and it\n              //has only three frames, or show the second frame if it\n              //only has two frames\n              if (o.tinkType === \"button\") {\n                if (o.totalFrames === 3) {\n                  o.gotoAndStop(2);\n                } else {\n                  o.gotoAndStop(1);\n                }\n              }\n            }\n\n\n            //Flag this pointer to be changed to a hand\n            pointer.shouldBeHand = true;\n            //if (pointer.visible) pointer.cursor = \"pointer\";\n          // } else {\n          //   //Turn the pointer to an ordinary arrow icon if the\n          //   //pointer isn't touching a sprite\n          //   if (pointer.visible) pointer.cursor = \"auto\";\n          }\n\n          //Perform the correct interactive action\n\n          //a. Run the `press` method if the sprite state is \"down\" and\n          //the sprite hasn't already been pressed\n          if (o.state === \"down\") {\n            if (!o.pressed) {\n              if (o.press) o.press();\n              o.pressed = true;\n              o.action = \"pressed\";\n            }\n          }\n\n          //b. Run the `release` method if the sprite state is \"over\" and\n          //the sprite has been pressed\n          if (o.state === \"over\") {\n            if (o.pressed) {\n              if (o.release) o.release();\n              o.pressed = false;\n              o.action = \"released\";\n              //If the pointer was tapped and the user assigned a `tap`\n              //method, call the `tap` method\n              if (pointer.tapped && o.tap) o.tap();\n            }\n\n            //Run the `over` method if it has been assigned\n            if (!o.hoverOver) {\n              if (o.over) o.over();\n              o.hoverOver = true;\n            }\n          }\n\n          //c. Check whether the pointer has been released outside\n          //the sprite's area. If the button state is \"up\" and it's\n          //already been pressed, then run the `release` method.\n          if (o.state === \"up\") {\n            if (o.pressed) {\n              if (o.release) o.release();\n              o.pressed = false;\n              o.action = \"released\";\n            }\n\n            //Run the `out` method if it has been assigned\n            if (o.hoverOver) {\n              if (o.out) o.out();\n              o.hoverOver = false;\n            }\n          }\n        }\n      });\n      if (pointer.shouldBeHand) {\n        pointer.cursor = \"pointer\";\n      } else {\n        pointer.cursor = \"auto\";\n      }\n    });\n  }\n\n  //A function that creates a sprite with 3 frames that\n  //represent the button states: up, over and down\n  button(source, x = 0, y = 0) {\n\n    //The sprite object that will be returned\n    let o;\n\n    //Is it an array of frame ids or textures?\n    if (typeof source[0] === \"string\") {\n\n      //They're strings, but are they pre-existing texture or\n      //paths to image files?\n      //Check to see if the first element matches a texture in the\n      //cache\n      if (this.TextureCache[source[0]]) {\n\n        //It does, so it's an array of frame ids\n        o = this.AnimatedSprite.fromFrames(source);\n      } else {\n\n        //It's not already in the cache, so let's load it\n        o = this.AnimatedSprite.fromImages(source);\n      }\n    }\n\n    //If the `source` isn't an array of strings, check whether\n    //it's an array of textures\n    else if (source[0] instanceof this.Texture) {\n\n      //Yes, it's an array of textures. \n      //Use them to make a AnimatedSprite o \n      o = new this.AnimatedSprite(source);\n    }\n\n    //Add interactive properties to the button\n    this.makeInteractive(o);\n\n    //Set the `tinkType` to \"button\"\n    o.tinkType = \"button\";\n\n    //Position the button\n    o.x = x;\n    o.y = y;\n\n    //Return the new button sprite\n    return o;\n  }\n\n  //Run the `udpate` function in your game loop\n  //to update all of Tink's interactive objects\n  update() {\n\n    //Update the drag and drop system\n    if (this.draggableSprites.length !== 0) this.updateDragAndDrop(this.draggableSprites);\n\n    //Update the buttons and button-like interactive sprites\n    if (this.buttons.length !== 0) this.updateButtons();\n  }\n\n  /*\n  `keyboard` is a method that listens for and captures keyboard events. It's really\n  just a convenient wrapper function for HTML `keyup` and `keydown` events so that you can keep your application code clutter-free and easier to write and read.\n\n  Here's how to use the `keyboard` method. Create a new keyboard object like this:\n  ```js\n  let keyObject = keyboard(asciiKeyCodeNumber);\n  ```\n  It's one argument is the ASCII key code number of the keyboard key\n  that you want to listen for. [Here's a list of ASCII key codes you can\n  use](http://www.asciitable.com).\n  Then assign `press` and `release` methods to the keyboard object like this:\n  ```js\n  keyObject.press = () => {\n    //key object pressed\n  };\n  keyObject.release = () => {\n    //key object released\n  };\n  ```\n  Keyboard objects also have `isDown` and `isUp` Boolean properties that you can use to check the state of each key. \n  */\n  keyboard(keyCode) {\n    let key = {};\n    key.code = keyCode;\n    key.isDown = false;\n    key.isUp = true;\n    key.press = undefined;\n    key.release = undefined;\n\n    //The `downHandler`\n    key.downHandler = event => {\n      if (event.keyCode === key.code) {\n        if (key.isUp && key.press) key.press();\n        key.isDown = true;\n        key.isUp = false;\n      }\n      event.preventDefault();\n    };\n\n    //The `upHandler`\n    key.upHandler = event => {\n      if (event.keyCode === key.code) {\n        if (key.isDown && key.release) key.release();\n        key.isDown = false;\n        key.isUp = true;\n      }\n      event.preventDefault();\n    };\n\n    //Attach event listeners\n    window.addEventListener(\n      \"keydown\", key.downHandler.bind(key), false\n    );\n    window.addEventListener(\n      \"keyup\", key.upHandler.bind(key), false\n    );\n\n    //Return the key object\n    return key;\n  }\n\n  //`arrowControl` is a convenience method for updating a sprite's velocity\n  //for 4-way movement using the arrow directional keys. Supply it\n  //with the sprite you want to control and the speed per frame, in\n  //pixels, that you want to update the sprite's velocity\n  arrowControl(sprite, speed) {\n\n    if (speed === undefined) {\n      throw new Error(\"Please supply the arrowControl method with the speed at which you want the sprite to move\");\n    }\n\n    let upArrow = this.keyboard(38),\n      rightArrow = this.keyboard(39),\n      downArrow = this.keyboard(40),\n      leftArrow = this.keyboard(37);\n\n    //Assign key `press` methods\n    leftArrow.press = () => {\n      //Change the sprite's velocity when the key is pressed\n      sprite.vx = -speed;\n      sprite.vy = 0;\n    };\n    leftArrow.release = () => {\n      //If the left arrow has been released, and the right arrow isn't down,\n      //and the sprite isn't moving vertically: \n      //Stop the sprite\n      if (!rightArrow.isDown && sprite.vy === 0) {\n        sprite.vx = 0;\n      }\n    };\n    upArrow.press = () => {\n      sprite.vy = -speed;\n      sprite.vx = 0;\n    };\n    upArrow.release = () => {\n      if (!downArrow.isDown && sprite.vx === 0) {\n        sprite.vy = 0;\n      }\n    };\n    rightArrow.press = () => {\n      sprite.vx = speed;\n      sprite.vy = 0;\n    };\n    rightArrow.release = () => {\n      if (!leftArrow.isDown && sprite.vy === 0) {\n        sprite.vx = 0;\n      }\n    };\n    downArrow.press = () => {\n      sprite.vy = speed;\n      sprite.vx = 0;\n    };\n    downArrow.release = () => {\n      if (!upArrow.isDown && sprite.vx === 0) {\n        sprite.vy = 0;\n      }\n    };\n  }\n}"]}