{"version":3,"sources":["../src/tink.js"],"names":[],"mappings":"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","file":"tink.js","sourcesContent":["class Tink {\n  constructor(PIXI, element, scale = 1) {\n\n    //Add element and scale properties\n    this.element = element;\n    this._scale = scale;\n\n    //An array to store all the draggable sprites\n    this.draggableSprites = [];\n\n    //An array to store all the pointer objects\n    //(there will usually just be one)\n    this.pointers = [];\n\n    //An array to store all the buttons and button-like\n    //interactive sprites\n    this.buttons = [];\n\n    //A local PIXI reference\n    this.PIXI = PIXI;\n\n    //Aliases for Pixi objects\n    this.TextureCache = this.PIXI.utils.TextureCache;\n\n    //Note: change MovieClip to AnimatedSprite for Pixi v4\n    this.AnimatedSprite = this.PIXI.extras.MovieClip;\n    this.Texture = this.PIXI.Texture;\n  }\n\n  get scale() {\n    return this._scale;\n  }\n\n  set scale(value) {\n    this._scale = value;\n\n    //Update scale values for all pointers\n    this.pointers.forEach(pointer => pointer.scale = value);\n  }\n\n  //`makeDraggable` lets you make a drag-and-drop sprite by pushing it\n  //into the `draggableSprites` array\n  makeDraggable(...sprites) {\n\n    //If the first argument isn't an array of sprites...\n    if (!(sprites[0] instanceof Array)) {\n      sprites.forEach(sprite => {\n        this.draggableSprites.push(sprite);\n\n        //If the sprite's `draggable` property hasn't already been defined by\n        //another library, like Hexi, define it\n        if (sprite.draggable === undefined) {\n          sprite.draggable = true;\n          sprite._localDraggableAllocation = true;\n        }\n      });\n    }\n\n    //If the first argument is an array of sprites...\n    else {\n      let spritesArray = sprites[0];\n      if (spritesArray.length > 0) {\n        for (let i = spritesArray.length - 1; i >= 0; i--) {\n          let sprite = spritesArray[i];\n          this.draggableSprites.push(sprite);\n\n          //If the sprite's `draggable` property hasn't already been defined by\n          //another library, like Hexi, define it\n          if (sprite.draggable === undefined) {\n            sprite.draggable = true;\n            sprite._localDraggableAllocation = true;\n          }\n        }\n      }\n    }\n  }\n\n  //`makeUndraggable` removes the sprite from the `draggableSprites`\n  //array\n  makeUndraggable(...sprites) {\n\n    //If the first argument isn't an array of sprites...\n    if (!(sprites[0] instanceof Array)) {\n      sprites.forEach(sprite => {\n        this.draggableSprites.splice(this.draggableSprites.indexOf(sprite), 1);\n        if (sprite._localDraggableAllocation === true) sprite.draggable = false;\n      });\n    }\n\n    //If the first argument is an array of sprites\n    else {\n      let spritesArray = sprites[0];\n      if (spritesArray.length > 0) {\n        for (let i = spritesArray.length - 1; i >= 0; i--) {\n          let sprite = spritesArray[i];\n          this.draggableSprites.splice(this.draggableSprites.indexOf(sprite), 1);\n          if (sprite._localDraggableAllocation === true) sprite.draggable = false;\n        }\n      }\n    }\n  }\n\n  makePointer(element = this.element, scale = this.scale) {\n\n    //Get a reference to Tink's global `draggableSprites` array\n    let draggableSprites = this.draggableSprites;\n\n    //Get a reference to Tink's `addGlobalPositionProperties` method\n    let addGlobalPositionProperties = this.addGlobalPositionProperties;\n\n    //The pointer object will be returned by this function\n    let pointer = {\n      element: element,\n      _scale: scale,\n\n      //Private x and y properties\n      _x: 0,\n      _y: 0,\n\n      //Width and height\n      width: 1,\n      height: 1,\n\n      //The public x and y properties are divided by the scale. If the\n      //HTML element that the pointer is sensitive to (like the canvas)\n      //is scaled up or down, you can change the `scale` value to\n      //correct the pointer's position values\n      get x() {\n        return this._x / this.scale;\n      },\n      get y() {\n        return this._y / this.scale;\n      },\n\n      //Add `centerX` and `centerY` getters so that we\n      //can use the pointer's coordinates with easing\n      //and collision functions\n      get centerX() {\n        return this.x;\n      },\n      get centerY() {\n        return this.y;\n      },\n\n      //`position` returns an object with x and y properties that\n      //contain the pointer's position\n      get position() {\n        return {\n          x: this.x,\n          y: this.y\n        };\n      },\n\n      get scale() {\n        return this._scale;\n      },\n      set scale(value) {\n        this._scale = value;\n      },\n\n      //Add a `cursor` getter/setter to change the pointer's cursor\n      //style. Values can be \"pointer\" (for a hand icon) or \"auto\" for \n      //an ordinary arrow icon.\n      get cursor() {\n        return this.element.style.cursor;\n      },\n      set cursor(value) {\n        this.element.style.cursor = value;\n      },\n\n      //Booleans to track the pointer state\n      isDown: false,\n      isUp: true,\n      tapped: false,\n\n      //Properties to help measure the time between up and down states\n      downTime: 0,\n      elapsedTime: 0,\n\n      //Optional `press`,`release` and `tap` methods\n      press: undefined,\n      release: undefined,\n      tap: undefined,\n\n      //A `dragSprite` property to help with drag and drop\n      dragSprite: null,\n\n      //The drag offsets to help drag sprites\n      dragOffsetX: 0,\n      dragOffsetY: 0,\n\n      //A property to check whether or not the pointer\n      //is visible\n      _visible: true,\n      get visible() {\n        return this._visible;\n      },\n      set visible(value) {\n        if (value === true) {\n          this.cursor = \"auto\";\n        } else {\n          this.cursor = \"none\";\n        }\n        this._visible = value;\n      },\n\n      //The pointer's mouse `moveHandler`\n      moveHandler(event) {\n\n        //Get the element that's firing the event\n        let element = event.target;\n\n        //Find the pointerâ€™s x and y position (for mouse).\n        //Subtract the element's top and left offset from the browser window\n        this._x = (event.pageX - element.offsetLeft);\n        this._y = (event.pageY - element.offsetTop);\n\n        //Prevent the event's default behavior \n        event.preventDefault();\n      },\n\n      //The pointer's `touchmoveHandler`\n      touchmoveHandler(event) {\n        let element = event.target;\n\n        //Find the touch point's x and y position\n        this._x = (event.targetTouches[0].pageX - element.offsetLeft);\n        this._y = (event.targetTouches[0].pageY - element.offsetTop);\n        event.preventDefault();\n      },\n\n      //The pointer's `downHandler`\n      downHandler(event) {\n\n        //Set the down states\n        this.isDown = true;\n        this.isUp = false;\n        this.tapped = false;\n\n        //Capture the current time\n        this.downTime = Date.now();\n\n        //Call the `press` method if it's been assigned\n        if (this.press) this.press();\n        event.preventDefault();\n      },\n\n      //The pointer's `touchstartHandler`\n      touchstartHandler(event) {\n        let element = event.target;\n\n        //Find the touch point's x and y position\n        this._x = event.targetTouches[0].pageX - element.offsetLeft;\n        this._y = event.targetTouches[0].pageY - element.offsetTop;\n\n        //Set the down states\n        this.isDown = true;\n        this.isUp = false;\n        this.tapped = false;\n\n        //Capture the current time\n        this.downTime = Date.now();\n\n        //Call the `press` method if it's been assigned\n        if (this.press) this.press();\n        event.preventDefault();\n      },\n\n      //The pointer's `upHandler`\n      upHandler(event) {\n\n        //Figure out how much time the pointer has been down\n        this.elapsedTime = Math.abs(this.downTime - Date.now());\n\n        //If it's less than 200 milliseconds, it must be a tap or click\n        if (this.elapsedTime <= 200 && this.tapped === false) {\n          this.tapped = true;\n\n          //Call the `tap` method if it's been assigned\n          if (this.tap) this.tap();\n        }\n        this.isUp = true;\n        this.isDown = false;\n\n        //Call the `release` method if it's been assigned\n        if (this.release) this.release();\n\n        //`event.preventDefault();` needs to be disabled to prevent <input> range sliders\n        //from getting trapped in Firefox (and possibly Safari)\n        //event.preventDefault();\n      },\n\n      //The pointer's `touchendHandler`\n      touchendHandler(event) {\n\n        //Figure out how much time the pointer has been down\n        this.elapsedTime = Math.abs(this.downTime - Date.now());\n\n        //If it's less than 200 milliseconds, it must be a tap or click\n        if (this.elapsedTime <= 200 && this.tapped === false) {\n          this.tapped = true;\n\n          //Call the `tap` method if it's been assigned\n          if (this.tap) this.tap();\n        }\n        this.isUp = true;\n        this.isDown = false;\n\n        //Call the `release` method if it's been assigned\n        if (this.release) this.release();\n        \n        //event.preventDefault();\n      },\n\n      //`hitTestSprite` figures out if the pointer is touching a sprite\n      hitTestSprite(sprite) {\n\n        //Add global `gx` and `gy` properties to the sprite if they\n        //don't already exist\n        addGlobalPositionProperties(sprite);\n\n        //The `hit` variable will become `true` if the pointer is\n        //touching the sprite and remain `false` if it isn't\n        let hit = false;\n\n        //Find out the sprite's offset from its anchor point\n        let xAnchorOffset, yAnchorOffset;\n        if (sprite.anchor !== undefined) {\n          xAnchorOffset = sprite.width * sprite.anchor.x;\n          yAnchorOffset = sprite.height * sprite.anchor.y;\n        } else {\n          xAnchorOffset = 0;\n          yAnchorOffset = 0;\n        }\n\n        //Is the sprite rectangular?\n        if (!sprite.circular) {\n\n          //Get the position of the sprite's edges using global\n          //coordinates\n          let left = sprite.gx - xAnchorOffset,\n            right = sprite.gx + sprite.width - xAnchorOffset,\n            top = sprite.gy - yAnchorOffset,\n            bottom = sprite.gy + sprite.height - yAnchorOffset;\n\n          //Find out if the pointer is intersecting the rectangle.\n          //`hit` will become `true` if the pointer is inside the\n          //sprite's area\n          hit = this.x > left && this.x < right && this.y > top && this.y < bottom;\n        }\n\n        //Is the sprite circular?\n        else {\n          //Find the distance between the pointer and the\n          //center of the circle\n          let vx = this.x - (sprite.gx + (sprite.width / 2) - xAnchorOffset),\n            vy = this.y - (sprite.gy + (sprite.width / 2) - yAnchorOffset),\n            distance = Math.sqrt(vx * vx + vy * vy);\n\n          //The pointer is intersecting the circle if the\n          //distance is less than the circle's radius\n          hit = distance < sprite.width / 2;\n        }\n        //Check the value of `hit`\n        return hit;\n      }\n    };\n\n    //Bind the events to the handlers\n    //Mouse events\n    element.addEventListener(\n      \"mousemove\", pointer.moveHandler.bind(pointer), false\n    );\n    element.addEventListener(\n      \"mousedown\", pointer.downHandler.bind(pointer), false\n    );\n\n    //Add the `mouseup` event to the `window` to\n    //catch a mouse button release outside of the canvas area\n    window.addEventListener(\n      \"mouseup\", pointer.upHandler.bind(pointer), false\n    );\n\n    //Touch events\n    element.addEventListener(\n      \"touchmove\", pointer.touchmoveHandler.bind(pointer), false\n    );\n    element.addEventListener(\n      \"touchstart\", pointer.touchstartHandler.bind(pointer), false\n    );\n\n    //Add the `touchend` event to the `window` object to\n    //catch a mouse button release outside of the canvas area\n    window.addEventListener(\n      \"touchend\", pointer.touchendHandler.bind(pointer), false\n    );\n\n    //Disable the default pan and zoom actions on the `canvas`\n    element.style.touchAction = \"none\";\n\n    //Add the pointer to Tink's global `pointers` array\n    this.pointers.push(pointer);\n\n    //Return the pointer\n    return pointer;\n  }\n\n  //Many of Tink's objects, like pointers, use collision\n  //detection using the sprites' global x and y positions. To make\n  //this easier, new `gx` and `gy` properties are added to sprites\n  //that reference Pixi sprites' `getGlobalPosition()` values.\n  addGlobalPositionProperties(sprite) {\n    if (sprite.gx === undefined) {\n      Object.defineProperty(\n        sprite,\n        \"gx\", {\n          get() {\n            return sprite.getGlobalPosition().x;\n          }\n        }\n      );\n    }\n\n    if (sprite.gy === undefined) {\n      Object.defineProperty(\n        sprite,\n        \"gy\", {\n          get() {\n            return sprite.getGlobalPosition().y;\n          }\n        }\n      );\n    }\n  }\n\n  //A method that implments drag-and-drop functionality \n  //for each pointer\n  updateDragAndDrop(draggableSprites) {\n\n    //Create a pointer if one doesn't already exist\n    if (this.pointers.length === 0) {\n      this.makePointer(this.element, this.scale);\n    }\n\n    //Loop through all the pointers in Tink's global `pointers` array\n    //(there will usually just be one, but you never know)\n    this.pointers.forEach(pointer => {\n\n      //Check whether the pointer is pressed down\n      if (pointer.isDown) {\n\n        //You need to capture the co-ordinates at which the pointer was\n        //pressed down and find out if it's touching a sprite\n\n        //Only run pointer.code if the pointer isn't already dragging\n        //sprite\n        if (pointer.dragSprite === null) {\n\n          //Loop through the `draggableSprites` in reverse to start searching at the bottom of the stack\n          for (let i = draggableSprites.length - 1; i > -1; i--) {\n\n            //Get a reference to the current sprite\n            let sprite = draggableSprites[i];\n\n            //Check for a collision with the pointer using `hitTestSprite`\n            if (pointer.hitTestSprite(sprite) && sprite.draggable) {\n\n              //Calculate the difference between the pointer's\n              //position and the sprite's position\n              pointer.dragOffsetX = pointer.x - sprite.gx;\n              pointer.dragOffsetY = pointer.y - sprite.gy;\n\n              //Set the sprite as the pointer's `dragSprite` property\n              pointer.dragSprite = sprite;\n\n              //The next two lines re-order the `sprites` array so that the\n              //selected sprite is displayed above all the others.\n              //First, splice the sprite out of its current position in\n              //its parent's `children` array\n              let children = sprite.parent.children;\n              children.splice(children.indexOf(sprite), 1);\n\n              //Next, push the `dragSprite` to the end of its `children` array so that it's\n              //displayed last, above all the other sprites\n              children.push(sprite);\n\n              //Reorganize the `draggableSpites` array in the same way\n              draggableSprites.splice(draggableSprites.indexOf(sprite), 1);\n              draggableSprites.push(sprite);\n\n              //Break the loop, because we only need to drag the topmost sprite\n              break;\n            }\n          }\n        }\n\n        //If the pointer is down and it has a `dragSprite`, make the sprite follow the pointer's\n        //position, with the calculated offset\n        else {\n          pointer.dragSprite.x = pointer.x - pointer.dragOffsetX;\n          pointer.dragSprite.y = pointer.y - pointer.dragOffsetY;\n        }\n      }\n\n      //If the pointer is up, drop the `dragSprite` by setting it to `null`\n      if (pointer.isUp) {\n        pointer.dragSprite = null;\n      }\n\n      //Change the mouse arrow pointer to a hand if it's over a\n      //draggable sprite\n      draggableSprites.some(sprite => {\n        if (pointer.hitTestSprite(sprite) && sprite.draggable) {\n          if (pointer.visible) pointer.cursor = \"pointer\";\n          return true;\n        } else {\n          if (pointer.visible) pointer.cursor = \"auto\";\n          return false;\n        }\n      });\n    });\n  }\n\n  makeInteractive(o) {\n\n    //The `press`,`release`, `over`, `out` and `tap` methods. They're `undefined`\n    //for now, but they can be defined in the game program\n    o.press = o.press || undefined;\n    o.release = o.release || undefined;\n    o.over = o.over || undefined;\n    o.out = o.out || undefined;\n    o.tap = o.tap || undefined;\n\n    //The `state` property tells you the button's\n    //current state. Set its initial state to \"up\"\n    o.state = \"up\";\n\n    //The `action` property tells you whether its being pressed or\n    //released\n    o.action = \"\";\n\n    //The `pressed` and `hoverOver` Booleans are mainly for internal\n    //use in this code to help figure out the correct state.\n    //`pressed` is a Boolean that helps track whether or not\n    //the sprite has been pressed down\n    o.pressed = false;\n\n    //`hoverOver` is a Boolean which checks whether the pointer\n    //has hovered over the sprite\n    o.hoverOver = false;\n\n    //tinkType is a string that will be set to \"button\" if the \n    //user creates an object using the `button` function\n    o.tinkType = \"\";\n\n    //Set `enabled` to true to allow for interactivity\n    //Set `enabled` to false to disable interactivity\n    o.enabled = true;\n\n    //Add the sprite to the global `buttons` array so that it can\n    //be updated each frame in the `updateButtons method\n    this.buttons.push(o);\n  }\n\n  //The `updateButtons` method will be called each frame \n  //inside the game loop. It updates all the button-like sprites\n  updateButtons() {\n\n    //Create a pointer if one doesn't already exist\n    if (this.pointers.length === 0) {\n      this.makePointer(this.element, this.scale);\n    }\n\n    //Loop through all of Tink's pointers (there will usually\n    //just be one)\n    this.pointers.forEach(pointer => {\n\n      pointer.shouldBeHand = false;\n\n\n\n      //Loop through all the button-like sprites that were created\n      //using the `makeInteractive` method\n      this.buttons.forEach(o => {\n\n        //Only do this if the interactive object is enabled\n        if (o.enabled) {\n\n          //Figure out if the pointer is touching the sprite\n          let hit = pointer.hitTestSprite(o);\n\n          //1. Figure out the current state\n          if (pointer.isUp) {\n\n            //Up state\n            o.state = \"up\";\n\n            //Show the first image state frame, if this is a `Button` sprite\n            if (o.tinkType === \"button\") o.gotoAndStop(0);\n          }\n\n          //If the pointer is touching the sprite, figure out\n          //if the over or down state should be displayed\n          if (hit) {\n\n            //Over state\n            o.state = \"over\";\n\n            //Show the second image state frame if this sprite has\n            //3 frames and it's a `Button` sprite\n            if (o.totalFrames && o.totalFrames === 3 && o.tinkType === \"button\") {\n              o.gotoAndStop(1);\n            }\n\n            //Down state\n            if (pointer.isDown) {\n              o.state = \"down\";\n\n              //Show the third frame if this sprite is a `Button` sprite and it\n              //has only three frames, or show the second frame if it\n              //only has two frames\n              if (o.tinkType === \"button\") {\n                if (o.totalFrames === 3) {\n                  o.gotoAndStop(2);\n                } else {\n                  o.gotoAndStop(1);\n                }\n              }\n            }\n\n\n\n            //Flag this pointer to be changed to a hand\n            pointer.shouldBeHand = true;\n            //if (pointer.visible) pointer.cursor = \"pointer\";\n          // } else {\n          //   //Turn the pointer to an ordinary arrow icon if the\n          //   //pointer isn't touching a sprite\n          //   if (pointer.visible) pointer.cursor = \"auto\";\n\n            //Change the pointer icon to a hand\n            if (pointer.visible) pointer.cursor = \"pointer\";\n          } else {\n            //Turn the pointer to an ordinary arrow icon if the\n            //pointer isn't touching a sprite\n            if (pointer.visible) pointer.cursor = \"auto\";\n\n          }\n\n          //Perform the correct interactive action\n\n          //a. Run the `press` method if the sprite state is \"down\" and\n          //the sprite hasn't already been pressed\n          if (o.state === \"down\") {\n            if (!o.pressed) {\n              if (o.press) o.press();\n              o.pressed = true;\n              o.action = \"pressed\";\n            }\n          }\n\n          //b. Run the `release` method if the sprite state is \"over\" and\n          //the sprite has been pressed\n          if (o.state === \"over\") {\n            if (o.pressed) {\n              if (o.release) o.release();\n              o.pressed = false;\n              o.action = \"released\";\n              //If the pointer was tapped and the user assigned a `tap`\n              //method, call the `tap` method\n              if (pointer.tapped && o.tap) o.tap();\n            }\n\n            //Run the `over` method if it has been assigned\n            if (!o.hoverOver) {\n              if (o.over) o.over();\n              o.hoverOver = true;\n            }\n          }\n\n          //c. Check whether the pointer has been released outside\n          //the sprite's area. If the button state is \"up\" and it's\n          //already been pressed, then run the `release` method.\n          if (o.state === \"up\") {\n            if (o.pressed) {\n              if (o.release) o.release();\n              o.pressed = false;\n              o.action = \"released\";\n            }\n\n            //Run the `out` method if it has been assigned\n            if (o.hoverOver) {\n              if (o.out) o.out();\n              o.hoverOver = false;\n            }\n          }\n        }\n      });\n\n      if (pointer.shouldBeHand) {\n        pointer.cursor = \"pointer\";\n      } else {\n        pointer.cursor = \"auto\";\n      }\n\n\n    });\n  }\n\n  //A function that creates a sprite with 3 frames that\n  //represent the button states: up, over and down\n  button(source, x = 0, y = 0) {\n\n    //The sprite object that will be returned\n    let o;\n\n    //Is it an array of frame ids or textures?\n    if (typeof source[0] === \"string\") {\n\n      //They're strings, but are they pre-existing texture or\n      //paths to image files?\n      //Check to see if the first element matches a texture in the\n      //cache\n      if (this.TextureCache[source[0]]) {\n\n        //It does, so it's an array of frame ids\n        o = this.AnimatedSprite.fromFrames(source);\n      } else {\n\n        //It's not already in the cache, so let's load it\n        o = this.AnimatedSprite.fromImages(source);\n      }\n    }\n\n    //If the `source` isn't an array of strings, check whether\n    //it's an array of textures\n    else if (source[0] instanceof this.Texture) {\n\n      //Yes, it's an array of textures. \n      //Use them to make a AnimatedSprite o \n      o = new this.AnimatedSprite(source);\n    }\n\n    //Add interactive properties to the button\n    this.makeInteractive(o);\n\n    //Set the `tinkType` to \"button\"\n    o.tinkType = \"button\";\n\n    //Position the button\n    o.x = x;\n    o.y = y;\n\n    //Return the new button sprite\n    return o;\n  }\n\n  //Run the `udpate` function in your game loop\n  //to update all of Tink's interactive objects\n  update() {\n\n    //Update the drag and drop system\n    if (this.draggableSprites.length !== 0) this.updateDragAndDrop(this.draggableSprites);\n\n    //Update the buttons and button-like interactive sprites\n    if (this.buttons.length !== 0) this.updateButtons();\n  }\n\n  /*\n  `keyboard` is a method that listens for and captures keyboard events. It's really\n  just a convenient wrapper function for HTML `keyup` and `keydown` events so that you can keep your application code clutter-free and easier to write and read.\n\n  Here's how to use the `keyboard` method. Create a new keyboard object like this:\n  ```js\n  let keyObject = keyboard(asciiKeyCodeNumber);\n  ```\n  It's one argument is the ASCII key code number of the keyboard key\n  that you want to listen for. [Here's a list of ASCII key codes you can\n  use](http://www.asciitable.com).\n  Then assign `press` and `release` methods to the keyboard object like this:\n  ```js\n  keyObject.press = () => {\n    //key object pressed\n  };\n  keyObject.release = () => {\n    //key object released\n  };\n  ```\n  Keyboard objects also have `isDown` and `isUp` Boolean properties that you can use to check the state of each key. \n  */\n  keyboard(keyCode) {\n    let key = {};\n    key.code = keyCode;\n    key.isDown = false;\n    key.isUp = true;\n    key.press = undefined;\n    key.release = undefined;\n\n    //The `downHandler`\n    key.downHandler = event => {\n      if (event.keyCode === key.code) {\n        if (key.isUp && key.press) key.press();\n        key.isDown = true;\n        key.isUp = false;\n      }\n      event.preventDefault();\n    };\n\n    //The `upHandler`\n    key.upHandler = event => {\n      if (event.keyCode === key.code) {\n        if (key.isDown && key.release) key.release();\n        key.isDown = false;\n        key.isUp = true;\n      }\n      event.preventDefault();\n    };\n\n    //Attach event listeners\n    window.addEventListener(\n      \"keydown\", key.downHandler.bind(key), false\n    );\n    window.addEventListener(\n      \"keyup\", key.upHandler.bind(key), false\n    );\n\n    //Return the key object\n    return key;\n  }\n\n  //`arrowControl` is a convenience method for updating a sprite's velocity\n  //for 4-way movement using the arrow directional keys. Supply it\n  //with the sprite you want to control and the speed per frame, in\n  //pixels, that you want to update the sprite's velocity\n  arrowControl(sprite, speed) {\n\n    if (speed === undefined) {\n      throw new Error(\"Please supply the arrowControl method with the speed at which you want the sprite to move\");\n    }\n\n    let upArrow = this.keyboard(38),\n      rightArrow = this.keyboard(39),\n      downArrow = this.keyboard(40),\n      leftArrow = this.keyboard(37);\n\n    //Assign key `press` methods\n    leftArrow.press = () => {\n      //Change the sprite's velocity when the key is pressed\n      sprite.vx = -speed;\n      sprite.vy = 0;\n    };\n    leftArrow.release = () => {\n      //If the left arrow has been released, and the right arrow isn't down,\n      //and the sprite isn't moving vertically: \n      //Stop the sprite\n      if (!rightArrow.isDown && sprite.vy === 0) {\n        sprite.vx = 0;\n      }\n    };\n    upArrow.press = () => {\n      sprite.vy = -speed;\n      sprite.vx = 0;\n    };\n    upArrow.release = () => {\n      if (!downArrow.isDown && sprite.vx === 0) {\n        sprite.vy = 0;\n      }\n    };\n    rightArrow.press = () => {\n      sprite.vx = speed;\n      sprite.vy = 0;\n    };\n    rightArrow.release = () => {\n      if (!leftArrow.isDown && sprite.vy === 0) {\n        sprite.vx = 0;\n      }\n    };\n    downArrow.press = () => {\n      sprite.vy = speed;\n      sprite.vx = 0;\n    };\n    downArrow.release = () => {\n      if (!upArrow.isDown && sprite.vx === 0) {\n        sprite.vy = 0;\n      }\n    };\n  }\n}"]}